import { NETWORK, SECURITY } from ".";
import { DomainSocketObject, grpcObject, HttpObject, KcpObject, QUICObject, SockoptObject, TcpObject, WebSocketObject } from "../src/transport";

/**
* Certificate purpose, default value is `encipherment`
* * `encipherment`: Certificate used for TLS authentication and encryption
* * `verify`: The certificate is used to verify the remote TLS certificate. When using this option, the current certificate must be a CA certificate
* * `issue`: The certificate is used to issue other certificates. When using this option, the current certificate must be a CA certificate
* * `verifyclient`: The Certificate Authority certificate used to verify the identity of the client. When using this option, the current certificate must be a CA certificate (4.42.0+)
*/
const enum CERT_USAGE {
    encipherment = "encipherment",
    verify = "verify",
    issue = "issue",
    verifyclient = "verifyclient"
}

class CertificateObject {
    /**
     * Certificate purpose, default value is `encipherment`
     * * `encipherment`: Certificate used for TLS authentication and encryption
     * * `verify`: The certificate is used to verify the remote TLS certificate. When using this option, the current certificate must be a CA certificate
     * * `issue`: The certificate is used to issue other certificates. When using this option, the current certificate must be a CA certificate
     * * `verifyclient`: The Certificate Authority certificate used to verify the identity of the client. When using this option, the current certificate must be a CA certificate (4.42.0+)
     */
    usage: CERT_USAGE = CERT_USAGE.encipherment;

    /** Certificate file path, if generated by OpenSSL, the suffix is ​​`.crt`. */
    certificateFile: string;

    /**
     * Key file path, if generated by OpenSSL, the suffix is ​​`.key`.
     *
     * currently does not support key files that require passwords
     */
    keyFile: string;

    /**
     * CertificateObject
     * @param certificateFile certificate file path, if generated by using OpenSSL, the suffix is ​​.crt
     * @param keyFile key file path, if generated using OpenSSL, the suffix is ​​.key
     */
    constructor(certificateFile: string, keyFile: string) {
        this.certificateFile = certificateFile;
        this.keyFile = keyFile;
    }
}

/** TLS configuration */
class TLSObject {
    /**
     * Specifies the domain name of the server-side certificate, useful when the connection is established by IP
     *
     * When the target connection is specified by the domain name, for example, the domain name is received when Socks inbound, or the domain name is detected by the Sniffing function, this domain name will be automatically used for serverName, no manual configuration is required
     */
    serverName: string;

    /**
     * An array of strings specifying the ALPN value specified during the TLS handshake
     *
     * The default value is `["h2", "http/1.1"]`
     */
    alpn: string[] = ["h2", "http/1.1"];

    /**
     * Whether to allow insecure connections (client only)
     *
     * The default value is `false`. When the value is `true`, V2Ray will not check the validity of the TLS certificate provided by the remote host
     */
    allowInsecure: boolean = false;

    /**
     * Whether to disable the CA certificate that comes with the operating system
     *
     * The default value is false
     * * When the value is true, V2Ray will only use the certificate specified in certificates for TLS handshake
     * * When the value is false, V2Ray will only use the CA certificate that comes with the operating system for TLS handshake
     */
    disableSystemRoot: boolean = false;

    /** A list of certificates, each of which represents a certificate */
    certificates: CertificateObject[] = [];

    /**
     * Perform client certificate authentication on connection
     *
     * After turning on this option, the client will need to configure the client certificate to connect to the server
     *
     * (4.42.0+) Client certificates must be signed by a client certificate authority configured in the program. The system's built-in certificate authority and the certificate authority used to authenticate the server will not be automatically trusted
     */
    verifyClientCertificate: boolean = false;

    /**
     * TLSObject
     * @param serverName specifies the domain name of the server-side certificate
     */
    constructor(serverName: string) {
        this.serverName = serverName;
    }
}

/**
* StreamSettingsObject corresponds to the streamSettings item in the outbound and inbound protocol
* Each inbound and outbound connection can be configured with different transmission configurations, and streamSettings can be set to configure some transmissions
*/
class StreamSettingsObject {
    /** The network type used by the data stream, the default value is `"tcp"` */
    network: NETWORK = NETWORK.tcp;

    /** Whether to enable transport layer encryption, the supported options are `"none"` means no encryption (default value), `"tls"` means use TLS */
    security: SECURITY = SECURITY.none;

    /** TLS configuration. TLS is provided by Golang, supports TLS 1.3, does not support DTLS */
    tlsSettings: TLSObject = null;
    
    /** Configuration for TCP connection */
    tcpSettings: TcpObject = null;

    /** Configuration for mKCP connection */
    kcpSettings: KcpObject = null;

    /** Configuration for WebSocket connection */
    wsSettings: WebSocketObject = null;

    /** Configuration for HTTP/2 connections */
    httpSettings: HttpObject = null;

    /** Configuration for QUIC connections */
    quicSettings: QUICObject = null;

    /** Configuration for Domain Socket connection */
    dsSettings: DomainSocketObject = null;

    /** Configuration for gRPC connection */
    grpcSettings: grpcObject = null;

    /** Configuration for transparent proxy */
    sockopt: SockoptObject = new SockoptObject();
}

export { CERT_USAGE, CertificateObject, TLSObject, StreamSettingsObject };
